#!/usr/bin/python

#TODO: keep list of recently noticed queries to also show

import time
import datetime
import os
import sys
import re

import psycopg2

import helpers_shellcolor as sc
import helpers_format

    
def colorqtype(q):
    ' ANSI-colors a string, based on the first word in the query '
    if ' ' in q:
        first,tail = q.strip().split(None,1) 
        tail = sc.darkgray(tail)
    else: # hacky
        first=q
        tail=''

    flow = first.lower()
    if flow=='select':
        return sc.yellow(first)+' '+tail 
    elif flow=='update':
        return sc.green(first)+' '+tail 
    elif flow=='insert':
        return sc.brightgreen(first)+' '+tail 
    elif flow=='delete':
        return sc.red(first)+' '+tail 
    elif flow=='commit':
        return sc.brightblue(first)+' '+tail 
    elif flow in ('vacuum', 'reindex',
                  'autovacuum:', 'analyse',
                  'create', 'drop',
                 ):
        return sc.magenta(first)+' '+tail 
    else:
        return first+' '+tail


    
def main():
    recent = {} # (starttime, pid) ->  (lastseen, query, state)

    from optparse import OptionParser    
    p = OptionParser() 
    p.add_option("-I", "--dont-ignore-boring",
                 dest="ignoreboring", default=True, action='store_false',
                 help="By default we ignore things like COMMIT, BEGIN, and ROLLBACK. This shows them.")

    p.add_option("-t", "--worktime-threshold",
                 dest="shortthresh", default='0.1', action='store_false',
                 help="Show only queries that took at least this many seconds. Defaults to 0.1. 0 shows more (but not all because we're polling), higher would help focus on long running queries.")
    
    p.add_option("-f", "--forget-time",
                 dest="forgettime", default='10',
                 help="Forget recent queries after this many seconds. Defaults to 10")
    
    p.add_option("-i", "--poll-interval",
                 dest="pollinterval", default='0.1',
                 help="Poll interval, in seconds. Defaults to 0.1. You can lower this to miss less.")

    p.add_option("-S", "--split-query",
                 dest="splitquery", default=True, action='store_false',
                 help="Default is to (re)split query over lines for readability. This puts it all on one line.")  # CONSIDER: truncating
    p.add_option("-m", "--max-query-lines",
                 dest="querylines", default='10',
                 help="Show first this-many lines of the split query. Defaults to 10.") 
    options, args = p.parse_args()  # defaults to parsing sys.argv[1:].  May exit the program.
    
    ignore_boring        =       options.ignoreboring
    short_running_thresh = float(options.shortthresh)
    splitquery           =       options.splitquery
    maxlines             =   int(options.querylines)
    recent_seconds       = float(options.forgettime)
    interval_sec         = float(options.pollinterval)

 
    while True:
        conn = psycopg2.connect('dbname=postgres user=postgres host=localhost connect_timeout=5')
        curs = conn.cursor()
            
        curs.execute('SELECT NOW()')  # to print age based on server time and avoid timezone confusion
        now, = curs.fetchone()

        # TODO: figure out which fits for which version
        #curs.execute('SELECT pid, datname, usename, xact_start, query_start, waiting, state, query  FROM pg_stat_activity ORDER BY pid')
        curs.execute('SELECT pid, datname, usename, xact_start, query_start, state, query  FROM pg_stat_activity ORDER BY pid')
        rows = curs.fetchall()
        curs.close()
        conn.close()

        ## show usernames only when there is more than one user (or maybe 'if any not "postgres"')
        #usernames = set( row[2]  for row in rows if row[2] not in (None,) )
        #show_usernames = len(usernames)>1 
        
        idles = 0
        for pid, datname, username, xact_start, query_start, state, query in rows:
            #print `pid, datname, usename, xact_start, query_start, state, query`
            query=query.strip()

            # query time in seconds
            query_time = None
            if query_start:
                query_time = now - query_start#.replace(tzinfo=None)
                query_time = query_time.total_seconds()

            if 'pg_stat_activity' in query: # self (or other statusgetter),
                continue # don't report

            if state=='idle':        # idles are counted, but not shown (implicitly also ignores 'last but not current command' confusion)
                idles+=1
                continue

            if 'xact_start' in query: # self>
                continue
            if 'xact_commit' in query: # pg_top?
                continue
            if query_start == None: # unsure
                continue

            if ignore_boring and query in ('COMMIT','BEGIN','ROLLBACK'):
                continue

            if query_time < short_running_thresh: # ignore very short running queries
                continue
            
            waiting = 'waiting' in state

            # state can apparently be 'active', 'idle', 'idle in transaction',
            #      'idle in transaction (aborted)', 'fastbath function call', 'disabled'
            if state in ('working','waiting','active'): # (what are the others?)
                recent[ (query_start,pid) ] = (now, query, state, waiting, username)
            


        new = {} # will be next round's recent state
        toprint_active = []
        toprint_recent = []
        items = recent.items()
        items.sort(lambda a, b: cmp(b[0][0],a[0][0]))
        for (starttime,pid),  (lastseen,query, state, waiting, username) in items:
            # note that some logic counts on the above not putting in idle-state  in this data
            # and that we have our own memory of when it was active instead
            
            ### BOOKKEEPING
            # dump old stuff  (still printed this round)
            age          = (now-starttime ).total_seconds()
            inactive_age = (now-lastseen).total_seconds()
            if recent_seconds > inactive_age: # still printed but will be forgotten for the next round
                new[ (starttime,pid) ] = (lastseen,query, state, waiting, username)

            is_past = inactive_age > 0  # check whether that's quite how it reports

            
            ### SHOW
            msg = []
            # color state
            state_s = ' %10s  '%state
            if is_past:
                state_s = ' '*13
            else:
                if state in ('idle in transaction',) and inactive_time > 1.0: # you probably want to add some rollbacks
                    state_s = sc.orange(state_s)
                elif state in ('waiting',):                                   # probably waiting on a lock
                        state_s = sc.red(state_s)
                elif state in ('working','active'): 
                    if age > 5.0:                                             # slow query
                        state_s = sc.red(state_s)
                    elif age > 1.0:
                        state_s = sc.orange(state_s)                          # slowish query
            msg.append( state_s )
            
            #if show_usernames:
            #    print '%10s'%usename,

            #toprint.append( sc.darkgray( '%25s (%7s ago)   %s'%(tm,helpers_format.nicetimelength(ago), query) ) )

            msg.append( sc.darkgray('PID: %-10s'%pid) )

            
            msg.append( "Started %s ago"%( helpers_format.nicetimelength(age), ) )

            if inactive_age > 0:
                msg.append( "last seen %7s ago   (so took approx %7s)"%(
                    helpers_format.nicetimelength(inactive_age),
                    helpers_format.nicetimelength(age-inactive_age)
                    ) )

            msg.append('\n')


            # try to split query in a readable way (put on parameter?)
            if splitquery:
                for i,line in enumerate(list(line.strip()   for line in query.splitlines()[:maxlines])):
                    if i==0:
                        msg.append( colorqtype(line) )
                    else:
                        msg.append( sc.darkgray(line) )
            else:
                msg.append( colorqtype( re.sub('[\r\n\s]+', ' ', query) ) )
                    
            if inactive_age > 0:
                toprint_recent.append( ' '.join(msg) ) 
            else:
                toprint_active.append( ' '.join(msg) )

                
        print sc.clearscreen()

            
        if idles>0:
            print sc.yellow("# Idle connections: %d"%idles)
            print
            print
        
        print sc.green("# Active queries")
        if len(toprint_active)>0:
            for thing in toprint_active:
                print thing
                print sc.magenta('- '*40) # separator
        else:
            print "No active queries"

            
        if len(toprint_recent)>0:
            print 
            print 
            print 
            print sc.cyan("# Recent queries  (%d seconds)"%recent_seconds)
            for thing in toprint_recent:
                print thing
                print sc.magenta('- '*40) # separator
            
        recent = new
            
        
        time.sleep( interval_sec )
        
if __name__=='__main__':

    try: 
        import setproctitle         # I like my tmux titles informative
        setproctitle.setproctitle( os.path.basename(sys.argv[0]) )
    except ImportError:
        pass

    main()
