#!/usr/bin/python

#TODO: keep list of recently noticed queries to also show

import time, datetime
import os, sys
import re

import psycopg2

import helpers_shellcolor as sc




def nicetimelength(sec, long=False, joinon=' ', parts=2, future=''):
    """ Takes a relative amount of time (seconds as float/int, or a timedelta),
        returns a string like  '12min 47sec'.
    """
    if type(sec) is datetime.timedelta:       
       sec = sec.days*86400 + sec.seconds

    vals = [
        ('year',   'years',    'yr',   60.*60.*24.*365.      ),
        ('month',  'months',   'mo',   60.*60.*24.*30.6      ),
        ('week',   'weeks',    'wk',   60.*60.*24.*7         ),
        ('day',    'days',     'dy',   60.*60.*24.           ),
        ('hour',   'hours',    'hr',   60.*60.               ),
        ('minute', 'minutes',  'min',  60.                   ),
    ]
    ret=[]
    left = sec

    if left<0:
        ret.append(future)
        left = abs(left)

    roundme=False
    if left>10:
        roundme=True
    for one,many,shorts,insec in vals:
        if left>insec:
            howmany = int(left/insec)
            left -= howmany*insec
            if long:
                if howmany==1:
                    ret.append( '1 %s'%(one) )
                else:
                    ret.append( '%d %s'%(howmany,many) )
            else: # short form
                ret.append('%2d%-3s'%(howmany,shorts))
    if left>=0.:
        if roundme:
            if long:
                ret.append( '%d seconds'%(left) )
            else:
                ret.append( '%dsec'%(left) )
        else:
            if long:
                ret.append( '%.1f seconds'%(left) )
            else:
                ret.append( '%.1fsec'%( left ) )
    return joinon.join(ret[:parts])



def colorqtype(q):
    ' ANSI-colors a string, based on the first word in the query '
    if ' ' in q:
        first,tail = q.strip().split(None,1) 
        tail = sc.darkgray(tail)
    else: # hacky
        first=q
        tail=''
    flow = first.lower()
    if flow=='select':
        return sc.yellow(first)+' '+tail 
    elif flow=='update':
        return sc.green(first)+' '+tail 
    elif flow=='insert':
        return sc.brightgreen(first)+' '+tail 
    elif flow=='delete':
        return sc.red(first)+' '+tail 
    elif flow=='commit':
        return sc.brightblue(first)+' '+tail 
    elif flow in ('vacuum', 'reindex',
                  'autovacuum:', 'analyse',
                  'create', 'drop',
                 ):
        return sc.magenta(first)+' '+tail 
    else:
        return first+' '+tail


    
def main():
    recent = {} # (starttime, pid) ->  (lastseen, query, state)

    from optparse import OptionParser    
    p = OptionParser() 
    p.add_option("-I", "--dont-ignore-boring",
                 dest="ignoreboring", default=True, action='store_false',
                 help="By default we ignore things like COMMIT, BEGIN, and ROLLBACK. This shows them.")
    p.add_option("-t", "--worktime-threshold",
                 dest="shortthresh", default='0.1',
                 help="Show only active/recent queries that took at least this many seconds. Defaults to 0.1. 0 shows more (but not all, because we're polling).")
    p.add_option("-f", "--forget-time",
                 dest="forgettime", default='10',
                 help="Forget recent queries after this many seconds. Defaults to 10")
    p.add_option("-r", "--max-recent",
                 dest="maxrecent", default='20',
                 help="Show at most this-many recent queries, e.g. to avoid scrolling off the real ones. Defaults to 20.") 
    p.add_option("-i", "--poll-interval",
                 dest="pollinterval", default='0.1',
                 help="Poll interval, in seconds. Defaults to 0.1. You can lower this to miss less.")
    p.add_option("-S", "--split-query",
                 dest="splitquery", default=True, action='store_false',
                 help="Default is to (re)split query over lines for readability. This puts it all on one line.")  # CONSIDER: truncating
    p.add_option("-m", "--max-query-lines",
                 dest="querylines", default='10',
                 help="Show first this-many lines of the split query. Defaults to 10.") 
    options, args = p.parse_args()  # defaults to parsing sys.argv[1:].  May exit the program.

    ignore_boring        =       options.ignoreboring
    short_running_thresh = float(options.shortthresh)
    splitquery           =       options.splitquery
    maxrecent            =   int(options.maxrecent)
    maxlines             =   int(options.querylines)
    recent_seconds       = float(options.forgettime)
    interval_sec         = float(options.pollinterval)
    print options.shortthresh, short_running_thresh

    while True:
        conn = psycopg2.connect('dbname=postgres user=postgres host=localhost connect_timeout=5')
        curs = conn.cursor()
            
        curs.execute('SELECT NOW()')  # to print age based on server time and avoid timezone confusion
        now, = curs.fetchone()

        curs.execute('SHOW max_connections')  # to print age based on server time and avoid timezone confusion
        connlimit = int( curs.fetchone()[0] )
        
        # TODO: figure out which fits for which version
        #curs.execute('SELECT pid, datname, usename, xact_start, query_start, waiting, state, query  FROM pg_stat_activity ORDER BY pid')
        curs.execute('SELECT pid, datname, usename, xact_start, query_start, state, query  FROM pg_stat_activity ORDER BY pid')
        rows = curs.fetchall()
        curs.close()
        conn.close()
        
        ## show usernames only when there is more than one user (or maybe 'if any not "postgres"')
        usernames = set( row[2]  for row in rows if row[2] not in (None,) )
        show_usernames = len(usernames)>1

        # state can apparently be 'active', 'idle', 'idle in transaction', 'idle in transaction (aborted)', 'fastbath function call', 'disabled'

        connamt = 0
        idles, shorts, borings = 0, 0, 0
        iit = []
        for pid, datname, username, xact_start, query_start, state, query in rows:
            connamt += 1
            query=query.strip()

            # query time in seconds
            query_time = None
            if query_start:
                query_time = now - query_start#.replace(tzinfo=None)
                query_time = query_time.total_seconds()

            if 'pg_stat_activity' in query: # self (or other statusgetter),
                continue # don't report

            if state=='idle':        # idles are counted, but not shown   (avoids 'last but not current query' confusion)
                idles+=1
                continue

            if state!=None and 'idle in transaction' in state:
                iit.append( query )

            if 'xact_start' in query:  # self?   (check this)
                continue
            if 'xact_commit' in query: # pg_top? (check this)
                continue
            if query_start == None:    # unsure
                continue

            if ignore_boring and query in ('COMMIT','BEGIN','ROLLBACK'):
                borings += 1
                continue

            if query_time < short_running_thresh: # don't enter quickly-finished queries (ignore them completely)
                shorts += 1
                continue
            
            if state in ('working','waiting','active'): # (what are the others?)
                recent[ (query_start,pid) ] = (now, query, state, username)
            


        new = {} # will be next round's recent state
        toprint_active = []
        toprint_recent = []
        items = recent.items()
        items.sort(lambda a, b: cmp(b[0][0],a[0][0]))
        for (starttime,pid),  (lastseen,query, state, username) in items:
            waiting = 'waiting' in state
            
            # note that some logic counts on the above not putting in idle-state  in this data
            # and that we have our own memory of when it was active instead
            
            ### bookkeeping
            # dump old stuff  (still printed this round)
            age          = (now-starttime ).total_seconds()
            inactive_age = (now-lastseen).total_seconds()
            if recent_seconds > inactive_age: # still printed but will be forgotten for the next round
                new[ (starttime,pid) ] = (lastseen,query, state, username)
            
            is_past = inactive_age > 0  # check whether that's quite how it reports
            
            
            ### display logic
            msg = []
            # color state
            state_s = ' %10s  '%state
            if is_past:
                state_s = ' '*13
            else:
                if state in ('idle in transaction',) and inactive_time > 1.0: # you probably want to add some rollbacks
                    state_s = sc.orange(state_s)
                elif waiting:                                                 # waiting on a lock
                    state_s = sc.red(state_s)
                elif state in ('working','active'):
                    if age > 5.0:                                             # slow query
                        state_s = sc.red(state_s)
                    elif age > 1.0:
                        state_s = sc.orange(state_s)                          # slowish query
            msg.append( state_s )
            
            if show_usernames:
                msg.append( '%10s'%username )
            
            msg.append( sc.darkgray('PID: %-10s'%pid) )
            
            
            msg.append( "Started %s ago"%( nicetimelength(age), ) )
            
            if inactive_age > 0:
                msg.append( "   last seen %7s ago   (so took approx %7s)"%(
                    nicetimelength(inactive_age),
                    nicetimelength(age-inactive_age)
                    ) )
            
            msg.append('\n')
            
            
            # try to split query in a readable way (put on parameter?)
            if splitquery:
                for i,line in enumerate(list(line.strip()   for line in query.splitlines()[:maxlines])):
                    if i==0:
                        msg.append( colorqtype(line) )
                    else:
                        msg.append( sc.darkgray(line) )
            else: # maybe also have option for 'as is'?
                msg.append( colorqtype( re.sub('[\r\n\s]+', ' ', query) ) )
            
            # active or recent?
            if inactive_age > 0:
                if age-inactive_age > short_running_thresh:
                    toprint_recent.append( ' '.join(msg) )
                else:
                    shorts += 1
            else:
                toprint_active.append( ' '.join(msg) )
        
                
        # actually print
        print sc.clearscreen()
        
        print sc.brightblue("%d open connections,  %d idle   (limit: %d)"%(connamt, idles, connlimit))

        print sc.brightblue("Ignored short-running queries: %d"%shorts)
        #print sc.yellow("# Boring queries: %d"%borings)
        print sc.brightblue("Idle in transaction: %d"%len(iit))
        #for q in iit:
        #    print "#   most recent query: %s"%q
        print
        print
            
        print sc.green("# Active queries")
        if len(toprint_active)>0:
            for thing in toprint_active:
                print thing
                print sc.magenta('- '*40) # separator
        else:
            print "No active queries"
        
        
        if len(toprint_recent)>0:
            print 
            print 
            print 
            print sc.cyan("# Recent queries  (up to %s  from the last %d seconds)"%(maxrecent, recent_seconds, ))
            for thing in toprint_recent[:maxrecent]:
                print thing
                print sc.magenta('- '*40) # separator
        
        
        recent = new
        
        time.sleep( interval_sec )

        
        
if __name__=='__main__':

    try: 
        import setproctitle         # I like my tmux titles informative
        setproctitle.setproctitle( os.path.basename(sys.argv[0]) )
    except ImportError:
        pass

    main()
